" Test settings

" Themis settings {{{

call themis#option('recursive', 1)
call themis#option('reporter', 'spec')
call themis#helper('command')

" }}}

" Test utilities {{{

let g:Utils = {}

" Open a temporary buffer and return its buffer number.
function! Utils.tmp_buffer(name, ...)
  execute 'edit' a:name
  let another_command = get(a:, '1', '')
  if ! empty(another_command)
    execute another_command
  endif
  return bufnr('%')
endfunction

" Wipeout all specified buffers.
function! Utils.wipeout_all(bufnrs)
  for bufnr in a:bufnrs
    execute 'bwipeout' bufnr
  endfor
endfunction

" Mock actions {{{

" Create a mock actions dictionary that remembers what actions were called.
function! g:Utils.make_mock_actions()
  let mock_actions = { '_called' : {} }

  function! mock_actions._clear() dict
    let self._called = {}
  endfunction

  for s:action in keys(g:bufswitcher#action#actions)
    exec "function! mock_actions[s:action](...) dict\n"
      \ ."  let self._called." . s:action . " = a:000[1:]\n"
      \ ."endfunction"
  endfor
  return mock_actions
endfunction

" Custom matcher to check if the specified action was called.
function! ToBeCalled(mock_actions, action, arguments)
  if ! has_key(a:mock_actions._called, a:action)
    return 0
  endif

  let actual_args = a:mock_actions._called[a:action]
  return actual_args ==# a:arguments
endfunction

function! ToBeCalled_Message(not, name, mock, action, arguments)
  let verb        = a:not ? "doesn't call" : "calls"
  let called      = has_key(a:mock._called, a:action)
  let actual_args = called ? a:mock._called[a:action] : '-'

  return printf(join([
    \ "Expected it %s the '%s' action with the arguments %s.",
    \ "Result:",
    \ "   action: %s",
    \ "   arguments: %s"
    \ ], "\n"),
    \ verb, a:action, string(a:arguments),
    \ called ? "called" : "not called", string(actual_args)
    \ )
endfunction

call themis#helper#expect#define_matcher('to_be_called',
  \ function('ToBeCalled'), function('ToBeCalled_Message'))

" }}}

" }}}

" vim: foldmethod=marker
